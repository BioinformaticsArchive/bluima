package ch.epfl.bbp.uima.topicmodels.estimator
import scala.Array.canBuildFrom
import scopt.immutable.OptionParser
import scala.collection.immutable.HashMap
import ch.epfl.bbp.uima.topicmodels.mallet.MalletUtils

/**
 * Estimation program for LDA models generated by PLDA
 */
object PLDAModelEstimation extends LikelihoodEstimation[PLDAConfig] {

  def main(args: Array[String]) {
    this.estimate(args, PLDAConfig())
  }

  override def getAlpha(c: PLDAConfig) = {
    println(topics(c))
    Array.fill[Double](topics(c))(c.alpha)
  }
  override def getBeta(c: PLDAConfig) = c.beta

  override def getTermTopicMatrix(c: PLDAConfig): Array[Array[Int]] = {
    val src = prepareFile(c.modelFile)
    val m = src.getLines()
      .map(l => l.dropWhile(_ != '\t').drop(1)
        .split(' ')
        .map(_.toDouble))
        .toArray
   
    MalletUtils.convertProbabilityMatrixToCountsMatrix(m, c.trainingCorpusSize)
  }

  override def getTokenDict(c: PLDAConfig): Map[String, Int] = {
    val src = prepareFile(c.tokenFile)

    // gets the tokens in the model file
    // in the PLDA model file, the tokens are considered as strings
    val tokenList = prepareFile(c.modelFile).getLines()
    				.map(l => l.split('\t').apply(0).trim)
    				.zipWithIndex
    				
    // maps some feature number to the corresponding index in the model file
    val tokenIndexToPLDAIndex = HashMap.empty[String, Int] ++ tokenList
  				
    // maps a feature to the corresponding row number in the matrix
    var map = HashMap.empty[String,Int]
    src.getLines()
    	.map(l => l.split(' '))
    	.filter(x => tokenIndexToPLDAIndex.contains(x(1).trim)) // out of vocabulary forms
    	.map(x => (x(0), tokenIndexToPLDAIndex(x(1).trim)))
    	.foreach(p => map += p)

    map
  }

  override def argumentParser() = {
    new OptionParser[PLDAConfig]("PLDALikelihoodEstimation") {
      def options = Seq(
        doubleOpt("a", "alpha", "alpha value") { (v: Double, c: PLDAConfig) => c.copy(alpha = v) },
        doubleOpt("b", "beta", "beta value") { (v: Double, c: PLDAConfig) => c.copy(beta = v) },
        intOpt("c", "cycles", "Number of estimation cycles") { (v: Int, c: PLDAConfig) => c.copy(cycles = v) },
        intOpt("t", "training-size", "Number of tokens in training corpus")  { (v: Int, c: PLDAConfig) => c.copy(trainingCorpusSize = v) },
        arg("<model_file>", "PLDA model file") { (v: String, c: PLDAConfig) => c.copy(modelFile = v) },
        arg("<test docs>", "Documents to test (one line per instance)") { (v: String, c: PLDAConfig) => c.copy(tests = v) },
        arg("<token file>", "Token file: one line per token") { (v: String, c: PLDAConfig) => c.copy(tokenFile = v) })
    }
  }

  private def topics(c: PLDAConfig): Int = {
    prepareFile(c.modelFile).getLine(0).split(' ').length
  }
}