package ch.epfl.bbp.uima.topicmodels.writers.exploitation
import java.io.BufferedOutputStream
import java.io.File
import java.io.FileOutputStream
import java.io.PrintStream
import scala.Array.canBuildFrom
import scala.collection.JavaConversions._
import org.apache.uima.analysis_component.JCasAnnotator_ImplBase
import org.apache.uima.jcas.JCas
import org.apache.uima.UimaContext
import org.apache.uima.fit.util.JCasUtil
import ch.epfl.bbp.uima.topicmodels.annotators.AnnotatorUtils
import ch.epfl.bbp.uima.types.Topic
import ch.epfl.bbp.uima.BlueCasUtil
import de.julielab.jules.types.Token
import org.apache.uima.fit.descriptor.TypeCapability

/**
 * Takes a CAS annotated with topics and generates for each CAS a text file where each token annotated 
 * with a topic is printed along with its most likely topic number. 
 * The text file can be chosen to be in LaTeX format or plain text.
 */
//@TypeCapability(inputs = Array(ch.epfl.bbp.uima.types.Topic), outputs = Array())
class AnnotateTokensWithTopicWriter extends JCasAnnotator_ImplBase {
  private type Formatter = (String, Double, Int) => String
  private var dir: File = null
  private var latex = false

  private var cnt = 0

  override def initialize(context: UimaContext) = {
    val dirPath = AnnotatorUtils.getStringParamFromContext(context, AnnotateTokensWithTopicWriter.OutputDir, "", true)
    dir = new File(dirPath)
    if(!dir.exists())
      dir.mkdirs()

    latex = AnnotatorUtils.getBooleanParamFromContext(context, AnnotateTokensWithTopicWriter.LatexOutput, latex, false)
  }

  override def process(doc: JCas) {
    val id = BlueCasUtil.getHeaderDocId(doc)

    val filename = if (id == null || id.length() == 0) cnt.toString
    			   else id
    			   
    val out = new PrintStream(new BufferedOutputStream(new FileOutputStream(dir.getAbsolutePath() + "/" + filename + ".txt")))

    val formatFct: Formatter = if (latex) latexFormatter
    						   else plainTextFormatter

    writeTokens(doc, formatFct, out)

    out.close
    
    cnt += 1
  }

  private def writeTokens(doc: JCas, formatToken: Formatter, out: PrintStream) {
    val topics = JCasUtil.select(doc, classOf[Topic]).toList

    val positions = topics.map(t => (t.getBegin, t.getEnd))
    val tokens = positions.map(p => JCasUtil.selectCovered(doc, classOf[Token], p._1, p._2).head)
    val tokensStr = tokens.map(_.getCoveredText)

    val mostLikelyIds = topics.map(t => t.getScores.toArray.zipWithIndex.max) // argmax over topics
    
    (tokensStr zip mostLikelyIds).map(p => (p._1, p._2._1, p._2._2))
      .map(t => formatToken(t._1, t._2, t._3))
      .foreach(out.print(_))
  }

  private def latexFormatter(s: String, score: Double, tid: Int) = "$\\textrm{" + s + "}_{" + (tid + 1) + "}$ "
  //private def plainTextFormatter(s: String, score: Double, tid: Int) = s + "(" + tid + ") "
  private def plainTextFormatter(s: String, score: Double, tid: Int) = s + "\t" + tid + "\n"
}
object AnnotateTokensWithTopicWriter {
  val OutputDir = "outputDir" // (String) the directory where the output files should be stored
  val LatexOutput = "latexOutput" // (boolean) LaTeX output (true) or text output (false and default)
}